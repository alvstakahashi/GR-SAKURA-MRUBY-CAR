/***********************************************************************/
/*                                                                     */
/*  FILE        :gcctestb.c                                            */
/*  DATE        :Mon, Jun 29, 2015                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :RX63N                                                 */
/*                                                                     */
/*  This file is generated by KPIT GNU Project Generator.              */
/*                                                                     */
/***********************************************************************/
                    
#include <stdint.h>	
#include <kernel.h>
#include "ssp/kernel_cfg.h"
																							
#include "iodefine.h"

extern const uint8_t
#if defined __GNUC__
__attribute__((aligned(4)))
#elif defined _MSC_VER
__declspec(align(4))
#endif
rb_main[];

extern void mruby_call(const uint8_t *mrb_p );

#ifdef CPPAPP
//Initialize global constructors
// The GNURX uses a different method to initialize global constructors
// The below call is not invoked in case of RX target
extern "C" void __main()
{
  static int initialized;
  if (! initialized)
    {
      typedef void (*pfunc) ();
      extern pfunc __ctors[];
      extern pfunc __ctors_end[];
      pfunc *p;

      initialized = 1;
      for (p = __ctors_end; p > __ctors; )
	(*--p) ();

    }
}
#endif 

int main(void)
{
    // TODO: add application code here

	printf("hello\n");
	
//	dly_tsk(1000);

	PORT2.PDR.BIT.B5 = 0;		//IN
//	PORT2.PCR.BIT.B5 = 1;		//PULLUP

	uint8_t *prg_data = (uint8_t *)rb_main;
	
#if !defined HEWSIM
	if (PORT2.PIDR.BIT.B5 != 0)		//IO5ÇGNDåãê¸Ç≈ÉXÉLÉbÉv
	{
		prg_data = mrb_read_ui();
		if (prg_data == NULL)
		{
			prg_data = (uint8_t *)rb_main;
		}
	}
#endif
	mruby_call((const uint8_t *)prg_data);
	
	printf("mruby_call End\n");
	
//	act_tsk(RUBY_TSK5);

//	PORTA.PODR.BIT.B0 = 1; 				// Output
//	PORT2.PODR.BIT.B2 = 1; 				// Output
//	sta_cyc(RUBY_CYC1);
//
//    while (1) {
//    }
  return 0;
}

void task2(intptr_t arg)
{
//	printf("task2\n");
//	PORTA.PDR.BIT.B0 ^= 1;				// Reverse (LED)
//	PORT2.PDR.BIT.B2 ^= 1;				// Reverse  P22 IO2
	
}

void CMI0()
{
	static int count=0;
	_kernel_signal_time();
	if (++count > 100)		// 10usÇ»ÇÃÇ≈ÅAä‘à¯Ç≠
	{
		count = 0;
		isig_tim();
	}
}

//// ssp_thread Ç≈ìoò^Ç≥ÇÍÇÈtaskñ{ëÃ
//void
//mrb_ssp_alarm_call(intptr_t exf)
//{
//	PORT2.PDR.BIT.B2 = 0;		// OFF  P22 IO2
//	return;
//}
//// ssp_thread Ç≈ìoò^Ç≥ÇÍÇÈtaskñ{ëÃ
//void
//mrb_ssp_cyclic_call(intptr_t exf)
//{
//	PORT2.PDR.BIT.B2 = 1;			// ON  P22 IO2
//	ista_alm(MAIN_ALM,190);
//	return;
//}
//// ssp_thread Ç≈ìoò^Ç≥ÇÍÇÈtaskñ{ëÃ
//void
//mrb_ssp_thread_call(intptr_t exf)
//{
//	return;
//}
